#include <mach-o/dyld.h>
#include <mach/mach.h>
#include <cstdint>
#include <cstdio>
#include <sys/mman.h>
#include <unistd.h>
#include <vector>
#include <libkern/OSCacheControl.h> // sys_icache_invalidate için
#include <dispatch/dispatch.h>      // dispatch_after için

uintptr_t get_image_vmaddr_slide() {
    return _dyld_get_image_vmaddr_slide(0);
}

uintptr_t calculate_address(uintptr_t offset) {
    return get_image_vmaddr_slide() + offset;
}

bool apply_patch(uintptr_t offset, std::vector<uint8_t> bytes) {
    uintptr_t target_addr = calculate_address(offset);
    size_t size = bytes.size();

    // Sistemdeki PAGE_SIZE'ı kullanıyoruz (0x4000 ile aynıdır)
    uintptr_t page_start = target_addr & ~(vm_page_size - 1);
    
    kern_return_t kr = vm_protect(mach_task_self(), (vm_address_t)page_start, vm_page_size, FALSE, VM_PROT_READ | VM_PROT_WRITE | VM_PROT_COPY);
    
    if (kr != KERN_SUCCESS) {
        return false;
    }

    memcpy((void *)target_addr, bytes.data(), size);

    vm_protect(mach_task_self(), (vm_address_t)page_start, vm_page_size, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);
    
    // CPU önbelleğini temizle
    sys_icache_invalidate((void *)target_addr, size);

    return true;
}

__attribute__((constructor))
static void init() {
    // 2 saniye bekle ve yamayı uygula
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        // Ofsetini buraya yazabilirsin kanka
        // apply_patch(0x123456, {0xC0, 0x03, 0x5F, 0xD6});
    });
}
